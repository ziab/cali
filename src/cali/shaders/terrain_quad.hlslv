#include "cali_common.fx"

/////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////
// Local functions
/////////////////////////////////////////////////////////////

float3 get_normal_from_heightmap_tex(Texture2D tex, SamplerState samp, float2 uv, float texel_size, float scale_factor)
{
    float h1 = tex.SampleLevel(samp, uv, 0) * scale_factor;
    float h2 = tex.SampleLevel(samp, uv + float2(texel_size, 0.0), 0) * scale_factor;
    float h3 = tex.SampleLevel(samp, uv + float2(texel_size, texel_size), 0) * scale_factor;

    float3 v1 = float3(uv.x, h1, uv.y);
    float3 v2 = float3(uv.x + texel_size, h2, uv.y);
    float3 v3 = float3(uv.x + texel_size, h3, uv.y + texel_size);

    float3 normal = cross(normalize(v3 - v1), normalize(v2 - v1));

    return normal;
}

float3 filter_normal(Texture2D tex, SamplerState samp, float2 uv, float texelSize, float texelAspect)
{
    float4 h;
    h[0] = tex.SampleLevel(samp, uv + texelSize * float2(0, -1), 0).r * texelAspect;
    h[1] = tex.SampleLevel(samp, uv + texelSize * float2(-1, 0), 0).r * texelAspect;
    h[2] = tex.SampleLevel(samp, uv + texelSize * float2(1, 0), 0).r * texelAspect;
    h[3] = tex.SampleLevel(samp, uv + texelSize * float2(0, 1), 0).r * texelAspect;
    float3 n;
    n.z = h[0] - h[3];
    n.x = h[1] - h[2];
    n.y = 2;

    return normalize(n);
}

/////////////////////////////////////////////////////////////////////////////////////
// https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code
/////////////////////////////////////////////////////////////////////////////////////
bool intersect_sphere(
    in float3 s, // the start point of the ray
    in float3 d, // a unit vector in the direction of the ray.
    in float3 c, // the center point of the sphere
    in float r, // its radius
    out float3 intersection,
    out float3 normal
)
{
    // Calculate ray start's offset from the sphere center
    float3 p = s - c;

    float r_squared = r * r;
    float p_d = dot(p, d);

    // The sphere is behind or surrounding the start point.
    if (p_d > 0 || dot(p, p) < r_squared)
        return false;

    // Flatten p into the plane passing through c perpendicular to the ray.
    // This gives the closest approach of the ray to the center.
    float3 a = p - p_d * d;

    float a_squared = dot(a, a);

    // Closest approach is outside the sphere.
    if (a_squared > r_squared)
        return false;

    // Calculate distance from plane where ray enters/exits the sphere.    
    float h = sqrt(r_squared - a_squared);

    // Calculate intersection point relative to sphere center.
    float3 i = a - h * d;

    intersection = c + i;
    normal = i / r;
    // We've taken a shortcut here to avoid a second square root.
    // Note numerical errors can make the normal have length slightly different from 1.
    // If you need higher precision, you may need to perform a conventional normalization.

    return true;
}

float2 get_texture_size(Texture2D _texture)
{
    uint tex_width, tex_height;
    _texture.GetDimensions(tex_width, tex_height);
    return float2(tex_width, tex_height);
}

static const float PI = 3.1415926;

/////////////////////////////////////////////////////////////
// Global Resources
/////////////////////////////////////////////////////////////

float4x4 IvModelViewProjectionMatrix;
float4x4 IvNormalMatrix;
float4x4 IvViewProjectionMatrix;
float4x4 IvModelMatrix;

float4x4 rotation_matrix;

Texture2D height_map;
SamplerState height_mapSampler;

float grid_stride;
float grid_cols;
float grid_rows;
float3 grid_uv_quad_size;
float3 grid_center;

float3 planet_center;
float planet_radius;
float planet_lon;
float planet_lat;
float curvature;

Texture3D<float4> quad_data;
SamplerState quad_dataSampler;

/*     -  
Z  /       \
|	 A - B
| |  |   |  |
|	 C - D
|	       /
|	   -
.------------X
*/

float3 quad_a;
float3 quad_b;
float3 quad_c;
float3 quad_d;

/////////////////////////////////////////////////////////////
// Main
/////////////////////////////////////////////////////////////

float4 grid_to_sphere_position(float4 p, float R, float3 C)
{
    float longitude = p.x / R + planet_lon;
    float latitude = 2 * atan(exp(p.z / R)) - PI / 2.0 + planet_lat;

    float cos_latitude = cos(latitude);

    float4 ps;
    ps.x = R * cos_latitude * sin(longitude);
    ps.y = R * cos_latitude * cos(longitude);
    ps.z = R * sin(latitude);
    ps.w = p.w;

    return ps + float4(C, 0.0);
}

float3 quad_lerp(
		in float3 a,
		in float3 b,
		in float3 c,
		in float3 d,
		in float2 uv)
{
	// Given a (u,v) coordinate that defines a 2D local position inside a planar quadrilateral, find the
	// absolute 3D (x,y,z) coordinate at that location.
	//
	//  0 <----u----> 1
	//  a ----------- b    0
	//  |             |   /|\
	//  |             |    |
	//  |             |    v
	//  |  *(u,v)     |    |
	//  |             |   \|/
	//  d------------ c    1
	//
	// a, b, c, and d are the vertices of the quadrilateral. They are assumed to exist in the
	// same plane in 3D space, but this function will allow for some non-planar error.
	//
	// Variables u and v are the two-dimensional local coordinates inside the quadrilateral.
	// To find a point that is inside the quadrilateral, both u and v must be between 0 and 1 inclusive.  
	// For example, if you send this function u=0, v=0, then it will return coordinate "a".  
	// Similarly, coordinate u=1, v=1 will return vector "c". Any values between 0 and 1
	// will return a coordinate that is bi-linearly interpolated between the four vertices.

    float3 abu = lerp(a, b, uv.x);
    float3 dcu = lerp(d, c, uv.x);
    return lerp(abu, dcu, uv.y);
}


VS_OUTPUT main(float2 uv : TEXCOORD, float3 normal : NORMAL, float4 position : POSITION)
{
    VS_OUTPUT output;

    ///////////////////////////////////////////////
    // calculate grid parameters

    float2 texture_size = get_texture_size(height_map);
    float2 grid_quad_size = float2(grid_uv_quad_size.x, grid_uv_quad_size.y);
    float2 grid_size = float2(grid_cols, grid_rows);

    float2 grid_center_uv = float2(grid_center.x, grid_center.z) / (grid_size * grid_stride);

    float2 translated_uv = (grid_center_uv + uv) * grid_quad_size;

    // loop the texture
    translated_uv = frac(abs(translated_uv));

    ///////////////////////////////////////////////
    //

    float3 world_position_inter = quad_lerp(quad_a, quad_b, quad_c, quad_d, uv + float2(0.5, 0.5));

    float4 displacement = quad_data.SampleLevel(quad_dataSampler, float3(uv + float2(0.5, 0.5), 0.0), 0);

    float4 displacement_world = mul(rotation_matrix, displacement);
    float4 world_position = float4(world_position_inter, 1.0) + displacement_world;

    ///////////////////////////////////////////////
    // matrix multiplication 

    //float4 world_position = mul(IvModelMatrix, position);
    float4 world_normal = mul(IvNormalMatrix, quad_data.SampleLevel(quad_dataSampler, float3(uv + float2(0.5, 0.5), 1.0), 0));

    ///////////////////////////////////////////////
    // calculate height
    
    //world_position += world_normal * sqrt(height_map.SampleLevel(height_mapSampler, translated_uv, 0).r) * 255.0 * 0.1;

    output.screen_position = mul(IvViewProjectionMatrix, world_position);
    output.world_position = world_position;
    output.normal = (float3) (mul(IvNormalMatrix, float4(
        get_normal_from_heightmap_tex(height_map, height_mapSampler, translated_uv, grid_uv_quad_size.x / grid_cols, grid_stride), 0)
    ));
    return output;
}
